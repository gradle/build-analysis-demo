/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package org.gradle.buildeng.app

import com.beust.jcommander.JCommander
import com.beust.jcommander.ParameterException
import org.gradle.buildeng.data.collection.GradleEnterpriseBuildScanCollector
import ratpack.exec.Operation
import ratpack.exec.internal.DefaultExecController
import ratpack.func.Block
import ratpack.util.Exceptions
import java.io.File
import java.io.PrintWriter
import java.util.concurrent.CountDownLatch
import java.util.concurrent.TimeUnit
import java.util.concurrent.atomic.AtomicReference

class App {
    fun runFeedbackLoopAnalysis() {
        val serverUrl = TODO()
        val username = TODO()
        val password = TODO()
        val outputFilePath = "/tmp/feedback2.tsv"

//        val exportClientSpec = ExportClientSpec(URI(serverUrl), username, password, 1, Paths.get(outputFilePath))
//        val exportClient = GradleEnterpriseExportClient(exportClientSpec)

        val writer = PrintWriter(File(outputFilePath))
        GradleEnterpriseBuildScanCollector(serverUrl, username, password, writer).writeBuilds()
//        StandaloneRatpackHarness.execute(exportClient.export(TaskTimingMetricsReduction(writer)))
    }

    private fun parseArgs(vararg args: String): CliArgs {
        val cliArgs = CliArgs()
        val jCommander = JCommander(cliArgs)
        try {
            jCommander.parse(*args)

            if (cliArgs.help) {
                jCommander.usage()
                System.exit(0)
            }
        } catch (e: ParameterException) {
            System.err.println(e.message)
            jCommander.usage()
            System.exit(1)
        }

        return cliArgs
    }
}

internal object StandaloneRatpackHarness {

    @JvmOverloads
    fun execute(op: Operation, awaitBackgroundTermination: Boolean = false) {
        val error = AtomicReference<Throwable>()
        val controller = DefaultExecController()
        try {
            val done = CountDownLatch(1)
            controller.fork()
                    .onComplete({ done.countDown() })
                    .onError({ error.set(it) })
                    .start(op)
            Exceptions.uncheck(Block { done.await() })
        } finally {
            controller.close()
            if (awaitBackgroundTermination) {
                Exceptions.uncheck<Boolean>({ controller.executor.awaitTermination(10, TimeUnit.MINUTES) })
            }
        }
        if (error.get() != null) {
            throw Exceptions.uncheck(error.get())
        }
    }

}

fun main(args: Array<String>) {
    // TODO: allow selective analysis using CLI args: run --tests --tasks --errors --feedback-loops
    App().runFeedbackLoopAnalysis()
}
